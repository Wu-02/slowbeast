#!/usr/bin/python3

from slowbeast.parsers.llvm import Parser as LLVMParser
import argparse
import sys
from os import mkdir
from os.path import join as pathjoin

from slowbeast.symexe.symbolicexecution import SEOptions
from slowbeast.util.debugging import set_debugging, print_stdout, print_stderr

def createArgParser():
    parser = argparse.ArgumentParser()
    parser.add_argument('prog', nargs=1, help='program to be analyzed')
    parser.add_argument('-dbg', action='store_true', help='write debugging messages')
    parser.add_argument('-entry', default='main', help='entry function')
    parser.add_argument('-out-dir', default='slowbeast-out', help='Directory for output files')
    parser.add_argument('-interactive', action='store_true', default=False, help='Introspect the run of the algorithm')
    parser.add_argument('-se-no-tests', action='store_true', help='Genereate no test files')
    parser.add_argument('-step', default='instr',
                        help='Set what is an execution step, one of: block, instr (block = execute the whole blocks instead of single instructions in one step.')
    parser.add_argument('-concretize-nondet', action='store_true', default=False,
                        help='Use random value for nondet values, thus follow one random path during execution.')
    parser.add_argument('-uninitialized-nondet', action='store_true', default=False,
                        help='Use nondet value for reads from uninitialized memory (instead of issuing an error).')
    parser.add_argument('-parse-only', action='store_true', help='only parse program and dump it (for debugging)')
    parser.add_argument('-kind', action='store_true', help='Use k-induction')
    parser.add_argument('-se', action='store_true', default=True,  help='Perform symbolic execution.')
    #parser.add_argument('-bmc', action='store_true', help='Perform bounded model checking.')

    return parser

def parseArgs():
    parser = createArgParser()
    args = parser.parse_args()

    valid_step = ['block', 'instr']

    if not args.step in valid_step:
        print_stderr("Invalid -step argument, must be one of: {0}, got '{1}'".format(valid_step, args.step),
                     color="RED")
        sys.exit(1)

    return args

def print_stats(engine):
    print_stdout(
        "Executed instructions: {0}".format(
            engine.stats.instructions),
        color='CYAN')
    print_stdout(
        "Executed paths: {0}".format(
            engine.stats.paths),
        color='CYAN')
    print_stdout(
        "Paths that reached exit: {0}".format(
            engine.stats.exited_paths),
        color='CYAN')
    print_stdout(
        "Paths that abnormally terminated: {0}".format(
            engine.stats.terminated_paths),
        color='CYAN')
    print_stdout(
        "Killed paths: {0}".format( engine.stats.killed_paths), color='CYAN')
    print_stdout(
        "Executed branch instructions: {0}".format(
            engine._executor.stats.branchings),
        color='CYAN')
    print_stdout(
        "Number of forks on branches: {0} (forked on {1}% of branches)".format(
            engine._executor.stats.branch_forks,
            0 if engine._executor.stats.branchings == 0 else
            100 *
            float(
                engine._executor.stats.branch_forks) /
            engine._executor.stats.branchings),
        color='CYAN')
    # this includes e.g. forks on assertions/memory resolution/etc.
    print_stdout(
        "Number of all forks: {0} (from {1} calls ({2}%) to fork())".format(
            engine._executor.stats.forks,
            engine._executor.stats.fork_calls,
            0 if engine._executor.stats.fork_calls == 0 else
            100 *
            float(
                engine._executor.stats.forks) /
            engine._executor.stats.fork_calls),
        color='CYAN')
    print_stdout(
        "Found errors: {0}".format(
            engine.stats.errors),
        color='CYAN')

class TestCaseGenerator:
    def __init__(self, outdir='slowbeast-out'):
        self._outputdir = outdir

    def _openfile(self, path):
        return open(pathjoin(self._outputdir, path), 'w')

    def processState(self, state):
        assert not state.isReady()

        filename=str(state.getID())
        if state.hasError():
            filename+= ".err"
        elif state.wasKilled():
            filename+= ".killed"
        elif state.isTerminated():
            filename+= ".abort"
        filename+=".test"

        with self._openfile(filename) as fl:
            fl.write(str(state.getStatus()))
            fl.write('\n')
            if state.hasError():
                fl.write(state.getError())
                fl.write('\n')
            fl.write('\n')
            state.dump(stream=fl)


def main():
    args = parseArgs()

    parser = LLVMParser()
    try:
        P = parser.parse(args.prog[0])
    except FileNotFoundError as e:
        print_stderr(str(e), color="RED")
        sys.exit(1)
    if not P:
        sys.exit(1)

    if args.parse_only:
        P.dump()
        sys.exit(0)

    if args.dbg:
        set_debugging()
        P.dump()

    entry = P.getFunction(args.entry)
    if not entry:
        print("Entry function not found: {0}".format(args.entry))
        sys.exit(1)

    if args.se_no_tests:
        testgen=None
    else:
        try:
            mkdir(args.out_dir)
        except OSError:
            print("The output dir exists, overwriting files in there")
            with open('{0}/program.txt'.format(args.out_dir), 'w') as f:
                P.dump(f)
        testgen = TestCaseGenerator(args.out_dir)

    P.setEntry(entry)

    assert args.se, "We only support symbolic execution now"

    opts = SEOptions()
    opts.concretize_nondets = args.concretize_nondet
    opts.uninit_is_nondet = args.uninitialized_nondet
    if args.step == 'block':
        opts.setBlockStep()
    opts.interactive = args.interactive

    if args.kind:
        from slowbeast.kindse.kindse import KindSymbolicExecutor
        SE = KindSymbolicExecutor(P, testgen, opts)
    else:
        from slowbeast.symexe.symbolicexecution import SymbolicExecutor
        SE = SymbolicExecutor(P, testgen, opts)
    try:
        SE.run()
        print_stats(SE)
    except KeyboardInterrupt:
        print_stdout("Interrupted...")
        print_stats(SE)

    sys.exit(0)

if __name__ == "__main__":
    main()
